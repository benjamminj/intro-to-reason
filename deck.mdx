import {Appear, Head} from 'mdx-deck';
import {AppearList, Img, SmallList, Li, AppearColumns, Column} from './components';
import { FullScreenCode, Split} from 'mdx-deck/layouts';
import {FullScreenCodeWithTitle, DarkBackground, ReasonBackground, FullScreen} from './layouts';

export {default as theme} from './theme.js';

# Intro to 
<br/>
<Img width="60vw" object-fit="contain" minWidth="auto" src="./img/reason-logo-word.svg" alt="Reason"/>

---
export default Split

<SmallList>

## About Me ğŸ‘¨ğŸ»â€ğŸ’»

- Front-End Engineer at AutoGravity
- [@benjamminj](https://twitter.com/benjamminj)
- Medium blog

</SmallList>

<Img minWidth="auto" width="50vw" src="./img/profile.jpeg" alt="Benjamin Johnson" />

---
export default ReasonBackground

# The Problem

---
export default FullScreen

<Img src="./img/paradise.jpg" width="100vw" height="100vh" />

---
export default FullScreen

<Img src="./img/chili.gif" width="100vw" height="100vh" minWidth="auto" objectFit="cover" />

---
export default ReasonBackground

# How do we keep code bases from becoming complex?

---

<AppearList>
  <li>Unit tests ğŸš¨</li>
  <li>Linters, Formatters âœ…</li>
  <li>Peer review ğŸ‘€</li>
  <li>Types ğŸ”“</li>
</AppearList>

---

> Types aren't a substitute for tests, or vice versa

---

## Types & JavaScript

<ul style={{ display: 'grid', 'grid-template-columns': '1fr 1fr 1fr', width: '100vw' }}>
  <Appear>
    <li>
      <h5>No types</h5>
      <Img height="75px" shape="square" src="./img/js.png" alt="No Types, Just JavaScript" />
    </li>
    <li>
      <h5>Types + JS</h5>
      <Img height="75px" shape="square" src="./img/typescript.png" alt="TypeScript" />
      <Img height="75px" shape="square" src="./img/flowtype.jpg" alt="Flow" />
    </li>
    <li>
      <h5>Compile-to-JS</h5>
      <Img minWidth="auto" objectFit="scale-down" height="75px" src="./img/dart.png" alt="Dart" />
      <Img height="75px" shape="square" src="./img/elm.png" alt="Elm" />
      <Img height="75px" shape="square" src="./img/reason-logo-word.svg" alt="Reason" />
    </li>
  </Appear>
</ul>
---
export default ReasonBackground

> "Reason lets you write simple, fast and quality type safe code while leveraging both the JavaScript & OCaml ecosystems."

---

<AppearList>
  <li>ğŸª Syntax extension of OCaml</li>
  <li>âš›ï¸ Same creator as React</li>
  <li>ğŸ‰ Uses a familiar syntax & workflows</li>
</AppearList>

---

# Why OCaml?

---
export default ReasonBackground

> "OCaml is an industrial strength programming language supporting functional, imperative and object-oriented styles"

---

<AppearList>
  <li>Battle-hardened over 20 years</li>
  <li>Immutable & functional by default</li>
  <li>Still allows imperative & mutable code</li>
  <li>Rock solid type system with awesome inference</li>
</AppearList>

---

# BuckleScript

---
<!-- // TODO -- recap of the reason ecosystem -->
---
export default ReasonBackground

# Syntax

---
export default FullScreenCodeWithTitle

## Functions

```reason
let add = (first, second) => first + second;

add(1, 2) /* 3 */
```

---
export default FullScreenCodeWithTitle

## All functions are automatically curried!

```reason
let mult = (a, b) => a * b;
let multCurries = a => b => a * b;

let times3 = mult(3);
let num = times3(4);
```
---
export default FullScreenCodeWithTitle

## Labelled arguments

```reason
let addText = (~addition, ~text) => text ++ addition;

addText(~addition="test", ~text="TODO -- this is a ")
/* "TODO -- this is a test" */
```
---
export default FullScreenCodeWithTitle

## Records

<!-- TODO -- better ex. -->

```reason
type myRecord = {
  a: int,
  b: string
};

let record = {
  a: 3,
  b: 4,
}
```

---
export default FullScreenCodeWithTitle

## Lists & Arrays

```reason
/* Lists are immutable & fast at adding items */
let list = [1, 2, 3, 4];
let addedList = [0, ...list];

/* By contrast, arrays are mutable and faster at random access */
let arr = [|"array", "syntax", "feels", "great,", "right?"|];
arr[3] = "a little strange,";

/* arr = [|"array", "syntax", "feels", "a little strange,", "right?"|] */
```

---
export default FullScreenCodeWithTitle

## Variant!

```reason
let letter = 
  | A
  | B
  | C(int);

let a = C(43);
```

---
export default FullScreenCodeWithTitle

## Pattern Matching!

```reason
/* TODO -- better example? */
let applyLetter = (letter) => 
  switch(letter) {
    | A => "the letter is A"
    | B => "the letter is B"
    | C(val) => "the letter C was passed with the value " ++ string_of_int(val)
  }

applyLetter(C(23));
```

---
export default FullScreenCodeWithTitle

## More Pattern Matching!

```reason
let getPostRecommendation = (posts) => {
  switch(posts) {
    | [] => "there aren't any posts!"
    | [articleName, ..._rest] when articleName == "intro to reason" => 
      "check this out! It's awesome!"
    | [articleName] => "check out " ++ "articleName"
    | [firstName, secondName, ..._rest] => 
      "try" ++ firstName ++ " or " ++ secondName
  }
};

getPostRecommendation(["intro to reason"]);
```
---
export default FullScreenCodeWithTitle

## Pipes

```reason
let add3 = (a) => a + 3;
let multBy4 = (a) => a * 4;

let endResult = 3 |> add3 |> multBy4;
/* multBy4(add3(3)) */

```
---
export default FullScreenCodeWithTitle

## Modules

```reason
/* Every file also doubles as a module! */
let myFn = (a) => FileName.map();

/* You can also declare internal modules */
module Math = {
  let add = (a, b) => a + b;
  let mult = (a, b) => a * b;
  let div = (a, b) => a / b;
}

let sum = Math.add(1,2);
```

---

# Did I mention React bindings???

---
<!-- TODO -- add a dank GIF here or something -->

---
export default FullScreenCodeWithTitle

## Stateless Components

```jsx
let component = ReasonReact.statelessComponent("Button");

let make = (~onClick, ~color, ~text, _children) => {
  ...component,
  render: _self => {
    <button onClick style={ReactDOMRe.Style.make(~background=color, ())}>
      {ReasonReact.string(text)}
    </button>
  }
}
```

---
export default FullScreenCodeWithTitle

## Stateful (Reducer) Components

```jsx
type state = int;

type action =
  | Increment(int)
  | Decrement;

let component = ReasonReact.reducerComponent("Counter");

let make = (~initialCount=0, _children) => {
  ...component,
  initialState = () => initialCount,
  reducer = (action, state) =>
    switch(action) {
      | Increment(amount) => ReasonReact.update(state + amount)
      | Decrement => ReasonReact.update(state - 1)
    },
  render: self => 
    <div>
      <button onClick={_ev => self.send(Increment(1))}>Increment!</button>
      <button onClick={_ev => self.send(Increment(5))}>Increment by 5!</button>
      <button onClick={_ev => self.send(Decrement)}>Decrement!</button>

      <h1>{self.state}</h1>
    </div>
};
```

---
export default ReasonBackground

# The end