import {Appear, Head} from 'mdx-deck';
import {AppearList, Img, SmallList, Li, AppearColumns, Column} from './components';
import { FullScreenCode, Split} from 'mdx-deck/layouts';
import {FullScreenCodeWithTitle, DarkBackground, ReasonBackground, FullScreen} from './layouts';

export {default as theme} from './theme.js';

# Intro to 
<br/>
<Img width="60vw" object-fit="contain" minWidth="auto" src="./img/reason-logo-word.svg" alt="Reason"/>

---
export default Split

<SmallList>

## About Me ğŸ‘¨ğŸ»â€ğŸ’»

- Front-End Engineer at AutoGravity
- [@benjamminj](https://twitter.com/benjamminj)

</SmallList>

<Img minWidth="auto" width="50vw" src="./img/profile.jpeg" alt="Benjamin Johnson" />

---
export default ReasonBackground

# The Problem

---
export default FullScreen

<Img src="./img/paradise.jpg" width="100vw" height="100vh" />

---
export default FullScreen

<Img src="./img/chili.gif" width="100vw" height="100vh" minWidth="auto" objectFit="cover" />

---
export default ReasonBackground

# How do we keep code bases from becoming complex?

---

<AppearList>
  <li>Unit tests ğŸš¨</li>
  <li>Linters, Formatters âœ…</li>
  <li>Peer review ğŸ‘€</li>
  <li>Types ğŸ”“</li>
</AppearList>

---

> Types aren't a substitute for tests, or vice versa.

---

## Typed JS Landscape

<ul style={{ display: 'grid', 'grid-template-columns': '1fr 1fr 1fr', width: '100vw' }}>
  <Appear>
    <li>
      <h5>No types</h5>
      <Img height="125px" shape="square" src="./img/js.png" alt="No Types, Just JavaScript" />
    </li>
    <li>
      <h5>Types + JS</h5>
      <Img height="125px" shape="square" src="./img/typescript.png" alt="TypeScript" />
      <Img height="125px" shape="square" src="./img/flowtype.jpg" alt="Flow" />
    </li>
    <li>
      <h5>Compile-to-JS</h5>
      <Img minWidth="auto" objectFit="scale-down" height="125px" src="./img/dart.png" alt="Dart" />
      <Img height="125px" shape="square" src="./img/elm.png" alt="Elm" />
      <Img height="125px" shape="square" src="./img/reason-logo-word.svg" alt="Reason" />
    </li>
  </Appear>
</ul>
---
export default ReasonBackground

> "Reason lets you write simple, fast and quality type safe code while leveraging both the JavaScript & OCaml ecosystems."

---

<AppearList>
  <li>ğŸª Syntax extension of OCaml</li>
  <li>âš›ï¸ Same creator as React</li>
  <li>ğŸ‰ Uses a familiar syntax & workflows</li>
</AppearList>

---

# Why OCaml?

---
export default ReasonBackground

> "OCaml is an industrial strength programming language supporting functional, imperative and object-oriented styles"

---

<AppearList>
  <li>Battle-hardened over 20 years</li>
  <li>Immutable & functional by default</li>
  <li>Still allows imperative & mutable code</li>
  <li>Rock solid type system with awesome inference</li>
  <li>Compiles to barebone assembly, iOS & Android</li>
</AppearList>

```notes
Since reason is a syntax for OCaml, we get all of this for free.

Ocaml is only 1/2 the picture, though. 

After all, this is a JS meetup.
```

---
export default ReasonBackground

# BuckleScript

---

> Compile Reason/OCaml into human readable, fast JavaScript.

```notes
BuckleScript is a compiler for OCaml --> JS

Since Reason is just a syntax _for_ OCaml, it can easily leverage this tool that already existed within the OCaml ecosystem to allow cross-platform ability instantly.
```
---

export default FullScreenCodeWithTitle

## Reason

```reason
let first = arr =>
  switch (arr) {
  | [] => None
  | [a, ..._rest] => Some(a)
  };
```

---
export default FullScreenCodeWithTitle

## Compiled BuckleScript

```javascript
// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE
'use strict';

var Js_primitive = require("./stdlib/js_primitive.js");

function first(arr) {
  if (arr) {
    return Js_primitive.some(arr[0]);
  }
}

exports.first = first;
/* No side effect */
```

---
export default ReasonBackground

> BuckleScript means that Reason code that can be compiled for web and native!

```notes

This is a rather complex ecosystem. We're talking about a new language on top of JS, adding
the "learning curve" of a static type system. This can cause us to ask ourselves if it's
even *switch slide* really worth it.

```

---

# Is all this really necessary?

---

> Reason might not be right for your codebase yet, but it's worth keeping an eye on. 

---
export default ReasonBackground

# Syntax

---
export default FullScreenCodeWithTitle

## Functions

```reason
let add = (first, second) => first + second;

add(1, 2) /* 3 */
```

---
export default FullScreenCodeWithTitle

## All functions are automatically curried!

```reason
let mult = (a, b) => a * b;
/* let multCurried = a => b => a * b; */

let times3 = mult(3);
let num = times3(4);
```
---
export default FullScreenCodeWithTitle

## Labelled arguments

```reason
let addText = (~addition, ~text) => text ++ addition;

addText(~addition="sweet!", ~text="labelled arguments are")
/* "labelled arguments are sweet!" */
```

```notes
Make sure to say something about the ++ operator.
```
---
export default FullScreenCodeWithTitle

## Records

```reason
type animal = {
  rank: int,
  species: string
};

let dog = {
  rank: 1,
  species: "Dog",
}

/* You can declare the type explicitly too! */
let cat: animal = {
  rank: 2,
  species: "Cat",
}
```

```notes
Make small note about record typing being inferred
```
---
export default FullScreenCodeWithTitle

## Lists & Arrays

```reason
/* Lists are immutable & fast at adding items */
let list = [1, 2, 3, 4];
let addedList = [0, ...list];

/* By contrast, arrays are mutable and faster at access/updates */
let arr = [|"array", "syntax", "feels", "great,", "right?"|];
arr[3] = "a little strange,";

/* arr = [|"array", "syntax", "feels", "a little strange,", "right?"|] */
```

---
export default FullScreenCodeWithTitle

## Variant!

```reason
let Vehicle = 
  | Car(make)
  | Plane
  | Boat;

let Toyota = Car("Toyota");
```

---
export default FullScreenCodeWithTitle

## Pattern Matching!

```reason
/* TODO -- better example? */
let getTransportation = (vehicle) => 
  switch(vehicle) {
    | Car(make) => "Travelling in a " ++ make ++ " on land! ğŸš—"
    | Boat => "Get your sea legs on ğŸš¢"
    | Plane => "We're flying! âœˆï¸"
  }

getTransportation(Car("Mercedes"));
/* "Travelling in a Mercedes on land! ğŸš—" */
```

---
export default FullScreenCodeWithTitle

## More Pattern Matching!

```reason
let getPostRecommendation = (posts) => {
  switch(posts) {
    | [] => "there aren't any posts!"
    | [articleName, ..._rest] when articleName == "Intro to Reason" => 
      "Check this out! It's sweet!"
    | [articleName] => "check out " ++ "articleName"
    | [firstName, secondName, ..._rest] => 
      "try" ++ firstName ++ " or " ++ secondName
  }
};

getPostRecommendation(["Intro to Reason"]);
```

```notes
When we start pattern matching on more data structs, the only JS equivalent is a whole lot of if/elses

There's currently a JS proposal for pattern-matching, but it's not quite ready yet.
```
---
export default FullScreenCodeWithTitle

## Pipes

```reason
let add3 = (a) => a + 3;
let multBy4 = (a) => a * 4;

let endResult = 3 |> add3 |> multBy4;
/* multBy4(add3(3)) */

```

```notes
Also, there's a JS proposal for pipes, I believe it's in STG 2
```
---
export default FullScreenCodeWithTitle

## Modules

```reason
/* Every file also doubles as a module! */
let myFn = a => FileName.map();

/* You can also import everything from a module into a file */
open FileName;
let  myFn = a => map();

/* You can also declare internal modules */
module Math = {
  let add = (a, b) => a + b;
  let mult = (a, b) => a * b;
  let div = (a, b) => a / b;
}

let sum = Math.add(1, 2);
```

```notes
TBH, the "every file is a module" can be awkward at times. I haven't worked on something big enough to run into naming collisions, but I would imagine it forces you to think about how you group modules / when to package stuff into packages.
```
---
export default ReasonBackground

# Did I mention React bindings???
---

## Stateless Components

```notes
Use in VS Code...will just be easier
```
---

## Stateful (Reducer) Components

```notes
Also use in VS Code...will just be easier
```
---
export default ReasonBackground

# Thanks! ğŸ‰